{
	"schemaVersion": 1,
	"source": "github",
	"owner": "facebook",
	"repo": "react",
	"sha": "0e72d2810a1c58cb816f5138829dbedaa545d6e2",
	"htmlUrl": "https://github.com/facebook/react/commit/0e72d2810a1c58cb816f5138829dbedaa545d6e2",
	"apiUrl": "https://api.github.com/repos/facebook/react/commits/0e72d2810a1c58cb816f5138829dbedaa545d6e2",
	"diffUrl": "https://github.com/facebook/react/commit/0e72d2810a1c58cb816f5138829dbedaa545d6e2.diff",
	"message": "[Flight] Add more DoS mitigations to Flight Reply, and harden Flight\n\nThis fixes security vulnerabilities in Server Functions.\n\nCo-authored-by: Josh Story <josh.c.story@gmail.com>\nCo-authored-by: Janka Uryga <lolzatu2@gmail.com>\nCo-authored-by: Hendrik Liebau <mail@hendrik-liebau.de>",
	"authorName": "Sebastian Markb√•ge",
	"authorEmail": "sebastian@calyptus.eu",
	"authoredAt": "2026-01-26T17:44:15Z",
	"committerName": "Hendrik Liebau",
	"committerEmail": "mail@hendrik-liebau.de",
	"committedAt": "2026-01-26T18:46:13Z",
	"parents": ["3e319a943cff862b8fbb8e96868f9f153a9e199d"],
	"stats": {
		"additions": 834,
		"deletions": 262,
		"total": 1096
	},
	"files": [
		{
			"filename": "packages/react-client/src/ReactFlightClient.js",
			"status": "modified",
			"additions": 57,
			"deletions": 33,
			"changes": 90,
			"patch": "@@ -94,6 +94,8 @@ import getComponentNameFromType from 'shared/getComponentNameFromType';\n \n import {getOwnerStackByComponentInfoInDev} from 'shared/ReactComponentInfoStack';\n \n+import hasOwnProperty from 'shared/hasOwnProperty';\n+\n import {injectInternals} from './ReactFlightClientDevToolsHook';\n \n import {OMITTED_PROP_ERROR} from 'shared/ReactFlightPropertyAccess';\n@@ -159,6 +161,8 @@ const INITIALIZED = 'fulfilled';\n const ERRORED = 'rejected';\n const HALTED = 'halted'; // DEV-only. Means it never resolves even if connection closes.\n \n+const __PROTO__ = '__proto__';\n+\n type PendingChunk<T> = {\n   status: 'pending',\n   value: null | Array<InitializationReference | (T => mixed)>,\n@@ -1544,7 +1548,16 @@ function fulfillReference(\n           }\n         }\n       }\n-      value = value[path[i]];\n+      const name = path[i];\n+      if (\n+        typeof value === 'object' &&\n+        value !== null &&\n+        hasOwnProperty.call(value, name)\n+      ) {\n+        value = value[name];\n+      } else {\n+        throw new Error('Invalid reference.');\n+      }\n     }\n \n     while (\n@@ -1580,7 +1593,9 @@ function fulfillReference(\n     }\n \n     const mappedValue = map(response, value, parentObject, key);\n-    parentObject[key] = mappedValue;\n+    if (key !== __PROTO__) {\n+      parentObject[key] = mappedValue;\n+    }\n \n     // If this is the root object for a model reference, where `handler.value`\n     // is a stale `null`, the resolved value can be used directly.\n@@ -1849,7 +1864,9 @@ function loadServerReference<A: Iterable<any>, T>(\n       response._encodeFormAction,\n     );\n \n-    parentObject[key] = resolvedValue;\n+    if (key !== __PROTO__) {\n+      parentObject[key] = resolvedValue;\n+    }\n \n     // If this is the root object for a model reference, where `handler.value`\n     // is a stale `null`, the resolved value can be used directly.\n@@ -2231,29 +2248,31 @@ function defineLazyGetter<T>(\n ): any {\n   // We don't immediately initialize it even if it's resolved.\n   // Instead, we wait for the getter to get accessed.\n-  Object.defineProperty(parentObject, key, {\n-    get: function () {\n-      if (chunk.status === RESOLVED_MODEL) {\n-        // If it was now resolved, then we initialize it. This may then discover\n-        // a new set of lazy references that are then asked for eagerly in case\n-        // we get that deep.\n-        initializeModelChunk(chunk);\n-      }\n-      switch (chunk.status) {\n-        case INITIALIZED: {\n-          return chunk.value;\n+  if (key !== __PROTO__) {\n+    Object.defineProperty(parentObject, key, {\n+      get: function () {\n+        if (chunk.status === RESOLVED_MODEL) {\n+          // If it was now resolved, then we initialize it. This may then discover\n+          // a new set of lazy references that are then asked for eagerly in case\n+          // we get that deep.\n+          initializeModelChunk(chunk);\n         }\n-        case ERRORED:\n-          throw chunk.reason;\n-      }\n-      // Otherwise, we didn't have enough time to load the object before it was\n-      // accessed or the connection closed. So we just log that it was omitted.\n-      // TODO: We should ideally throw here to indicate a difference.\n-      return OMITTED_PROP_ERROR;\n-    },\n-    enumerable: true,\n-    configurable: false,\n-  });\n+        switch (chunk.status) {\n+          case INITIALIZED: {\n+            return chunk.value;\n+          }\n+          case ERRORED:\n+            throw chunk.reason;\n+        }\n+        // Otherwise, we didn't have enough time to load the object before it was\n+        // accessed or the connection closed. So we just log that it was omitted.\n+        // TODO: We should ideally throw here to indicate a difference.\n+        return OMITTED_PROP_ERROR;\n+      },\n+      enumerable: true,\n+      configurable: false,\n+    });\n+  }\n   return null;\n }\n \n@@ -2564,14 +2583,16 @@ function parseModelString(\n           // In DEV mode we encode omitted objects in logs as a getter that throws\n           // so that when you try to access it on the client, you know why that\n           // happened.\n-          Object.defineProperty(parentObject, key, {\n-            get: function () {\n-              // TODO: We should ideally throw here to indicate a difference.\n-              return OMITTED_PROP_ERROR;\n-            },\n-            enumerable: true,\n-            configurable: false,\n-          });\n+          if (key !== __PROTO__) {\n+            Object.defineProperty(parentObject, key, {\n+              get: function () {\n+                // TODO: We should ideally throw here to indicate a difference.\n+                return OMITTED_PROP_ERROR;\n+              },\n+              enumerable: true,\n+              configurable: false,\n+            });\n+          }\n           return null;\n         }\n         // Fallthrough\n@@ -5183,6 +5204,9 @@ function parseModel<T>(response: Response, json: UninitializedModel): T {\n function createFromJSONCallback(response: Response) {\n   // $FlowFixMe[missing-this-annot]\n   return function (key: string, value: JSONValue) {\n+    if (key === __PROTO__) {\n+      return undefined;\n+    }\n     if (typeof value === 'string') {\n       // We can't use .bind here because we need the \"this\" value.\n       return parseModelString(response, this, key, value);"
		},
		{
			"filename": "packages/react-client/src/ReactFlightReplyClient.js",
			"status": "modified",
			"additions": 19,
			"deletions": 1,
			"changes": 20,
			"patch": "@@ -95,6 +95,8 @@ export type ReactServerValue =\n \n type ReactServerObject = {+[key: string]: ReactServerValue};\n \n+const __PROTO__ = '__proto__';\n+\n function serializeByValueID(id: number): string {\n   return '$' + id.toString(16);\n }\n@@ -361,6 +363,15 @@ export function processReply(\n   ): ReactJSONValue {\n     const parent = this;\n \n+    if (__DEV__) {\n+      if (key === __PROTO__) {\n+        console.error(\n+          'Expected not to serialize an object with own property `__proto__`. When parsed this property will be omitted.%s',\n+          describeObjectForErrorMessage(parent, key),\n+        );\n+      }\n+    }\n+\n     // Make sure that `parent[key]` wasn't JSONified before `value` was passed to us\n     if (__DEV__) {\n       // $FlowFixMe[incompatible-use]\n@@ -780,6 +791,10 @@ export function processReply(\n     if (typeof value === 'function') {\n       const referenceClosure = knownServerReferences.get(value);\n       if (referenceClosure !== undefined) {\n+        const existingReference = writtenObjects.get(value);\n+        if (existingReference !== undefined) {\n+          return existingReference;\n+        }\n         const {id, bound} = referenceClosure;\n         const referenceClosureJSON = JSON.stringify({id, bound}, resolveToJSON);\n         if (formData === null) {\n@@ -789,7 +804,10 @@ export function processReply(\n         // The reference to this function came from the same client so we can pass it back.\n         const refId = nextPartId++;\n         formData.set(formFieldPrefix + refId, referenceClosureJSON);\n-        return serializeServerReferenceID(refId);\n+        const serverReferenceId = serializeServerReferenceID(refId);\n+        // Store the server reference ID for deduplication.\n+        writtenObjects.set(value, serverReferenceId);\n+        return serverReferenceId;\n       }\n       if (temporaryReferences !== undefined && key.indexOf(':') === -1) {\n         // TODO: If the property name contains a colon, we don't dedupe. Escape instead."
		},
		{
			"filename": "packages/react-server-dom-esm/src/server/ReactFlightDOMServerNode.js",
			"status": "modified",
			"additions": 11,
			"deletions": 2,
			"changes": 13,
			"patch": "@@ -328,12 +328,17 @@ function prerenderToNodeStream(\n function decodeReplyFromBusboy<T>(\n   busboyStream: Busboy,\n   moduleBasePath: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const response = createResponse(\n     moduleBasePath,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   let pendingFiles = 0;\n   const queuedFields: Array<string> = [];\n@@ -399,7 +404,10 @@ function decodeReplyFromBusboy<T>(\n function decodeReply<T>(\n   body: string | FormData,\n   moduleBasePath: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -411,6 +419,7 @@ function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);"
		},
		{
			"filename": "packages/react-server-dom-parcel/src/server/ReactFlightDOMServerBrowser.js",
			"status": "modified",
			"additions": 5,
			"deletions": 1,
			"changes": 6,
			"patch": "@@ -245,7 +245,10 @@ export function registerServerActions(manifest: ServerManifest) {\n \n export function decodeReply<T>(\n   body: string | FormData,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -257,6 +260,7 @@ export function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);"
		},
		{
			"filename": "packages/react-server-dom-parcel/src/server/ReactFlightDOMServerEdge.js",
			"status": "modified",
			"additions": 5,
			"deletions": 1,
			"changes": 6,
			"patch": "@@ -250,7 +250,10 @@ export function registerServerActions(manifest: ServerManifest) {\n \n export function decodeReply<T>(\n   body: string | FormData,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -262,6 +265,7 @@ export function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);"
		},
		{
			"filename": "packages/react-server-dom-parcel/src/server/ReactFlightDOMServerNode.js",
			"status": "modified",
			"additions": 17,
			"deletions": 3,
			"changes": 20,
			"patch": "@@ -556,12 +556,17 @@ export function registerServerActions(manifest: ServerManifest) {\n \n export function decodeReplyFromBusboy<T>(\n   busboyStream: Busboy,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const response = createResponse(\n     serverManifest,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   let pendingFiles = 0;\n   const queuedFields: Array<string> = [];\n@@ -626,7 +631,10 @@ export function decodeReplyFromBusboy<T>(\n \n export function decodeReply<T>(\n   body: string | FormData,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -638,6 +646,7 @@ export function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);\n@@ -646,7 +655,10 @@ export function decodeReply<T>(\n \n export function decodeReplyFromAsyncIterable<T>(\n   iterable: AsyncIterable<[string, string | File]>,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const iterator: AsyncIterator<[string, string | File]> =\n     iterable[ASYNC_ITERATOR]();\n@@ -655,6 +667,8 @@ export function decodeReplyFromAsyncIterable<T>(\n     serverManifest,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n \n   function progress("
		},
		{
			"filename": "packages/react-server-dom-turbopack/src/server/ReactFlightDOMServerBrowser.js",
			"status": "modified",
			"additions": 5,
			"deletions": 1,
			"changes": 6,
			"patch": "@@ -239,7 +239,10 @@ function prerender(\n function decodeReply<T>(\n   body: string | FormData,\n   turbopackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -251,6 +254,7 @@ function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);"
		},
		{
			"filename": "packages/react-server-dom-turbopack/src/server/ReactFlightDOMServerEdge.js",
			"status": "modified",
			"additions": 11,
			"deletions": 2,
			"changes": 13,
			"patch": "@@ -244,7 +244,10 @@ function prerender(\n function decodeReply<T>(\n   body: string | FormData,\n   turbopackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -256,6 +259,7 @@ function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);\n@@ -265,7 +269,10 @@ function decodeReply<T>(\n function decodeReplyFromAsyncIterable<T>(\n   iterable: AsyncIterable<[string, string | File]>,\n   turbopackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const iterator: AsyncIterator<[string, string | File]> =\n     iterable[ASYNC_ITERATOR]();\n@@ -274,6 +281,8 @@ function decodeReplyFromAsyncIterable<T>(\n     turbopackMap,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n \n   function progress("
		},
		{
			"filename": "packages/react-server-dom-turbopack/src/server/ReactFlightDOMServerNode.js",
			"status": "modified",
			"additions": 17,
			"deletions": 3,
			"changes": 20,
			"patch": "@@ -548,12 +548,17 @@ function prerender(\n function decodeReplyFromBusboy<T>(\n   busboyStream: Busboy,\n   turbopackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const response = createResponse(\n     turbopackMap,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   let pendingFiles = 0;\n   const queuedFields: Array<string> = [];\n@@ -619,7 +624,10 @@ function decodeReplyFromBusboy<T>(\n function decodeReply<T>(\n   body: string | FormData,\n   turbopackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -631,6 +639,7 @@ function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);\n@@ -640,7 +649,10 @@ function decodeReply<T>(\n function decodeReplyFromAsyncIterable<T>(\n   iterable: AsyncIterable<[string, string | File]>,\n   turbopackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const iterator: AsyncIterator<[string, string | File]> =\n     iterable[ASYNC_ITERATOR]();\n@@ -649,6 +661,8 @@ function decodeReplyFromAsyncIterable<T>(\n     turbopackMap,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n \n   function progress("
		},
		{
			"filename": "packages/react-server-dom-unbundled/src/server/ReactFlightDOMServerNode.js",
			"status": "modified",
			"additions": 17,
			"deletions": 3,
			"changes": 20,
			"patch": "@@ -548,12 +548,17 @@ function prerender(\n function decodeReplyFromBusboy<T>(\n   busboyStream: Busboy,\n   webpackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const response = createResponse(\n     webpackMap,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   let pendingFiles = 0;\n   const queuedFields: Array<string> = [];\n@@ -619,7 +624,10 @@ function decodeReplyFromBusboy<T>(\n function decodeReply<T>(\n   body: string | FormData,\n   webpackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -631,6 +639,7 @@ function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);\n@@ -640,7 +649,10 @@ function decodeReply<T>(\n function decodeReplyFromAsyncIterable<T>(\n   iterable: AsyncIterable<[string, string | File]>,\n   webpackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const iterator: AsyncIterator<[string, string | File]> =\n     iterable[ASYNC_ITERATOR]();\n@@ -649,6 +661,8 @@ function decodeReplyFromAsyncIterable<T>(\n     webpackMap,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n \n   function progress("
		},
		{
			"filename": "packages/react-server-dom-webpack/src/server/ReactFlightDOMServerBrowser.js",
			"status": "modified",
			"additions": 5,
			"deletions": 1,
			"changes": 6,
			"patch": "@@ -239,7 +239,10 @@ function prerender(\n function decodeReply<T>(\n   body: string | FormData,\n   webpackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -251,6 +254,7 @@ function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);"
		},
		{
			"filename": "packages/react-server-dom-webpack/src/server/ReactFlightDOMServerEdge.js",
			"status": "modified",
			"additions": 11,
			"deletions": 2,
			"changes": 13,
			"patch": "@@ -244,7 +244,10 @@ function prerender(\n function decodeReply<T>(\n   body: string | FormData,\n   webpackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -256,6 +259,7 @@ function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);\n@@ -265,7 +269,10 @@ function decodeReply<T>(\n function decodeReplyFromAsyncIterable<T>(\n   iterable: AsyncIterable<[string, string | File]>,\n   webpackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const iterator: AsyncIterator<[string, string | File]> =\n     iterable[ASYNC_ITERATOR]();\n@@ -274,6 +281,8 @@ function decodeReplyFromAsyncIterable<T>(\n     webpackMap,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n \n   function progress("
		},
		{
			"filename": "packages/react-server-dom-webpack/src/server/ReactFlightDOMServerNode.js",
			"status": "modified",
			"additions": 17,
			"deletions": 3,
			"changes": 20,
			"patch": "@@ -548,12 +548,17 @@ function prerender(\n function decodeReplyFromBusboy<T>(\n   busboyStream: Busboy,\n   webpackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const response = createResponse(\n     webpackMap,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   let pendingFiles = 0;\n   const queuedFields: Array<string> = [];\n@@ -619,7 +624,10 @@ function decodeReplyFromBusboy<T>(\n function decodeReply<T>(\n   body: string | FormData,\n   webpackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   if (typeof body === 'string') {\n     const form = new FormData();\n@@ -631,6 +639,7 @@ function decodeReply<T>(\n     '',\n     options ? options.temporaryReferences : undefined,\n     body,\n+    options ? options.arraySizeLimit : undefined,\n   );\n   const root = getRoot<T>(response);\n   close(response);\n@@ -640,7 +649,10 @@ function decodeReply<T>(\n function decodeReplyFromAsyncIterable<T>(\n   iterable: AsyncIterable<[string, string | File]>,\n   webpackMap: ServerManifest,\n-  options?: {temporaryReferences?: TemporaryReferenceSet},\n+  options?: {\n+    temporaryReferences?: TemporaryReferenceSet,\n+    arraySizeLimit?: number,\n+  },\n ): Thenable<T> {\n   const iterator: AsyncIterator<[string, string | File]> =\n     iterable[ASYNC_ITERATOR]();\n@@ -649,6 +661,8 @@ function decodeReplyFromAsyncIterable<T>(\n     webpackMap,\n     '',\n     options ? options.temporaryReferences : undefined,\n+    undefined,\n+    options ? options.arraySizeLimit : undefined,\n   );\n \n   function progress("
		},
		{
			"filename": "packages/react-server/src/ReactFlightActionServer.js",
			"status": "modified",
			"additions": 49,
			"deletions": 9,
			"changes": 58,
			"patch": "@@ -7,7 +7,7 @@\n  * @flow\n  */\n \n-import type {Thenable, ReactFormState} from 'shared/ReactTypes';\n+import type {ReactFormState} from 'shared/ReactTypes';\n \n import type {\n   ServerManifest,\n@@ -20,26 +20,48 @@ import {\n   requireModule,\n } from 'react-client/src/ReactFlightClientConfig';\n \n-import {createResponse, close, getRoot} from './ReactFlightReplyServer';\n+import {\n+  createResponse,\n+  close,\n+  getRoot,\n+  MAX_BOUND_ARGS,\n+} from './ReactFlightReplyServer';\n \n type ServerReferenceId = any;\n \n function bindArgs(fn: any, args: any) {\n+  if (args.length > MAX_BOUND_ARGS) {\n+    throw new Error(\n+      'Server Function has too many bound arguments. Received ' +\n+        args.length +\n+        ' but the limit is ' +\n+        MAX_BOUND_ARGS +\n+        '.',\n+    );\n+  }\n+\n   return fn.bind.apply(fn, [null].concat(args));\n }\n \n function loadServerReference<T>(\n   bundlerConfig: ServerManifest,\n-  id: ServerReferenceId,\n-  bound: null | Thenable<Array<any>>,\n+  metaData: {\n+    id: string,\n+    bound: null | Promise<Array<any>>,\n+  },\n ): Promise<T> {\n+  const id: ServerReferenceId = metaData.id;\n+  if (typeof id !== 'string') {\n+    return (null: any);\n+  }\n   const serverReference: ServerReference<T> =\n     resolveServerReference<$FlowFixMe>(bundlerConfig, id);\n   // We expect most servers to not really need this because you'd just have all\n   // the relevant modules already loaded but it allows for lazy loading of code\n   // if needed.\n   const preloadPromise = preloadModule(serverReference);\n-  if (bound) {\n+  const bound = metaData.bound;\n+  if (bound instanceof Promise) {\n     return Promise.all([(bound: any), preloadPromise]).then(\n       ([args]: Array<any>) => bindArgs(requireModule(serverReference), args),\n     );\n@@ -57,13 +79,15 @@ function decodeBoundActionMetaData(\n   body: FormData,\n   serverManifest: ServerManifest,\n   formFieldPrefix: string,\n+  arraySizeLimit: void | number,\n ): {id: ServerReferenceId, bound: null | Promise<Array<any>>} {\n   // The data for this reference is encoded in multiple fields under this prefix.\n   const actionResponse = createResponse(\n     serverManifest,\n     formFieldPrefix,\n     undefined,\n     body,\n+    arraySizeLimit,\n   );\n   close(actionResponse);\n   const refPromise = getRoot<{\n@@ -89,6 +113,7 @@ export function decodeAction<T>(\n   const formData = new FormData();\n \n   let action: Promise<(formData: FormData) => T> | null = null;\n+  const seenActions = new Set<string>();\n \n   // $FlowFixMe[prop-missing]\n   body.forEach((value: string | File, key: string) => {\n@@ -97,21 +122,36 @@ export function decodeAction<T>(\n       formData.append(key, value);\n       return;\n     }\n-    // Later actions may override earlier actions if a button is used to override the default\n-    // form action.\n+    // Later actions may override earlier actions if a button is used to\n+    // override the default form action. However, we don't expect the same\n+    // action ref field to be sent multiple times in legitimate form data.\n     if (key.startsWith('$ACTION_REF_')) {\n+      if (seenActions.has(key)) {\n+        return;\n+      }\n+      seenActions.add(key);\n       const formFieldPrefix = '$ACTION_' + key.slice(12) + ':';\n       const metaData = decodeBoundActionMetaData(\n         body,\n         serverManifest,\n         formFieldPrefix,\n       );\n-      action = loadServerReference(serverManifest, metaData.id, metaData.bound);\n+      action = loadServerReference(serverManifest, metaData);\n       return;\n     }\n+    // A simple action with no bound arguments may appear twice in the form data\n+    // if a button specifies the same action as the default form action. We only\n+    // load the first one, as they're guaranteed to be identical.\n     if (key.startsWith('$ACTION_ID_')) {\n+      if (seenActions.has(key)) {\n+        return;\n+      }\n+      seenActions.add(key);\n       const id = key.slice(11);\n-      action = loadServerReference(serverManifest, id, null);\n+      action = loadServerReference(serverManifest, {\n+        id,\n+        bound: null,\n+      });\n       return;\n     }\n   });"
		},
		{
			"filename": "packages/react-server/src/ReactFlightReplyServer.js",
			"status": "modified",
			"additions": 563,
			"deletions": 196,
			"changes": 759,
			"patch": "@@ -34,6 +34,7 @@ import {ASYNC_ITERATOR} from 'shared/ReactSymbols';\n \n import hasOwnProperty from 'shared/hasOwnProperty';\n import getPrototypeOf from 'shared/getPrototypeOf';\n+import isArray from 'shared/isArray';\n \n interface FlightStreamController {\n   enqueueModel(json: string): void;\n@@ -55,6 +56,8 @@ const RESOLVED_MODEL = 'resolved_model';\n const INITIALIZED = 'fulfilled';\n const ERRORED = 'rejected';\n \n+const __PROTO__ = '__proto__';\n+\n type RESPONSE_SYMBOL_TYPE = 'RESPONSE_SYMBOL'; // Fake symbol type.\n const RESPONSE_SYMBOL: RESPONSE_SYMBOL_TYPE = (Symbol(): any);\n \n@@ -79,7 +82,7 @@ type ResolvedModelChunk<T> = {\n type InitializedChunk<T> = {\n   status: 'fulfilled',\n   value: T,\n-  reason: null,\n+  reason: null | NestedArrayContext,\n   then(resolve: (T) => mixed, reject?: (mixed) => mixed): void,\n };\n type InitializedStreamChunk<\n@@ -194,6 +197,8 @@ export type Response = {\n   _closed: boolean,\n   _closedReason: mixed,\n   _temporaryReferences: void | TemporaryReferenceSet,\n+  _rootArrayContexts: WeakMap<$ReadOnlyArray<mixed>, NestedArrayContext>,\n+  _arraySizeLimit: number,\n };\n \n export function getRoot<T>(response: Response): Thenable<T> {\n@@ -210,13 +215,14 @@ function wakeChunk<T>(\n   response: Response,\n   listeners: Array<InitializationReference | (T => mixed)>,\n   value: T,\n+  chunk: InitializedChunk<T>,\n ): void {\n   for (let i = 0; i < listeners.length; i++) {\n     const listener = listeners[i];\n     if (typeof listener === 'function') {\n       listener(value);\n     } else {\n-      fulfillReference(response, listener, value);\n+      fulfillReference(response, listener, value, chunk.reason);\n     }\n   }\n }\n@@ -236,33 +242,6 @@ function rejectChunk(\n   }\n }\n \n-function resolveBlockedCycle<T>(\n-  resolvedChunk: SomeChunk<T>,\n-  reference: InitializationReference,\n-): null | InitializationHandler {\n-  const referencedChunk = reference.handler.chunk;\n-  if (referencedChunk === null) {\n-    return null;\n-  }\n-  if (referencedChunk === resolvedChunk) {\n-    // We found the cycle. We can resolve the blocked cycle now.\n-    return reference.handler;\n-  }\n-  const resolveListeners = referencedChunk.value;\n-  if (resolveListeners !== null) {\n-    for (let i = 0; i < resolveListeners.length; i++) {\n-      const listener = resolveListeners[i];\n-      if (typeof listener !== 'function') {\n-        const foundHandler = resolveBlockedCycle(resolvedChunk, listener);\n-        if (foundHandler !== null) {\n-          return foundHandler;\n-        }\n-      }\n-    }\n-  }\n-  return null;\n-}\n-\n function wakeChunkIfInitialized<T>(\n   response: Response,\n   chunk: SomeChunk<T>,\n@@ -271,45 +250,9 @@ function wakeChunkIfInitialized<T>(\n ): void {\n   switch (chunk.status) {\n     case INITIALIZED:\n-      wakeChunk(response, resolveListeners, chunk.value);\n+      wakeChunk(response, resolveListeners, chunk.value, chunk);\n       break;\n     case BLOCKED:\n-      // It is possible that we're blocked on our own chunk if it's a cycle.\n-      // Before adding back the listeners to the chunk, let's check if it would\n-      // result in a cycle.\n-      for (let i = 0; i < resolveListeners.length; i++) {\n-        const listener = resolveListeners[i];\n-        if (typeof listener !== 'function') {\n-          const reference: InitializationReference = listener;\n-          const cyclicHandler = resolveBlockedCycle(chunk, reference);\n-          if (cyclicHandler !== null) {\n-            // This reference points back to this chunk. We can resolve the cycle by\n-            // using the value from that handler.\n-            fulfillReference(response, reference, cyclicHandler.value);\n-            resolveListeners.splice(i, 1);\n-            i--;\n-            if (rejectListeners !== null) {\n-              const rejectionIdx = rejectListeners.indexOf(reference);\n-              if (rejectionIdx !== -1) {\n-                rejectListeners.splice(rejectionIdx, 1);\n-              }\n-            }\n-            // The status might have changed after fulfilling the reference.\n-            switch ((chunk: SomeChunk<T>).status) {\n-              case INITIALIZED:\n-                const initializedChunk: InitializedChunk<T> = (chunk: any);\n-                wakeChunk(response, resolveListeners, initializedChunk.value);\n-                return;\n-              case ERRORED:\n-                if (rejectListeners !== null) {\n-                  rejectChunk(response, rejectListeners, chunk.reason);\n-                }\n-                return;\n-            }\n-          }\n-        }\n-      }\n-    // Fallthrough\n     case PENDING:\n       if (chunk.value) {\n         for (let i = 0; i < resolveListeners.length; i++) {\n@@ -331,7 +274,7 @@ function wakeChunkIfInitialized<T>(\n       break;\n     case ERRORED:\n       if (rejectListeners) {\n-        wakeChunk(response, rejectListeners, chunk.reason);\n+        rejectChunk(response, rejectListeners, chunk.reason);\n       }\n       break;\n   }\n@@ -472,22 +415,73 @@ function loadServerReference<A: Iterable<any>, T>(\n     // as \"thenable\" which reduces to ReactPromise with no other fields.\n     return (null: any);\n   }\n+\n+  // Check for a cached promise from a previous call with the same metadata.\n+  // This handles deduplication when the same server reference appears multiple\n+  // times in the payload.\n+  const cachedPromise: SomeChunk<T> | void = (metaData: any).$$promise;\n+  if (cachedPromise !== undefined) {\n+    if (cachedPromise.status === INITIALIZED) {\n+      // The value was already resolved by a previous call.\n+      const resolvedValue: T = cachedPromise.value;\n+      if (key === __PROTO__) {\n+        return (null: any);\n+      }\n+      parentObject[key] = resolvedValue;\n+      return (resolvedValue: any);\n+    }\n+\n+    // The promise is still blocked. Increment the handler dependency count ...\n+    let handler: InitializationHandler;\n+    if (initializingHandler) {\n+      handler = initializingHandler;\n+      handler.deps++;\n+    } else {\n+      handler = initializingHandler = {\n+        chunk: null,\n+        value: null,\n+        reason: null,\n+        deps: 1,\n+        errored: false,\n+      };\n+    }\n+    // ... and register resolve and reject listeners on the promise.\n+    cachedPromise.then(\n+      resolveReference.bind(null, response, handler, parentObject, key),\n+      rejectReference.bind(null, response, handler),\n+    );\n+\n+    // Return a place holder value for now.\n+    return (null: any);\n+  }\n+\n+  // This is the first call for this server reference metadata. Create a cached\n+  // promise to be used for subsequent calls.\n+  // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors\n+  const blockedPromise: BlockedChunk<T> = new ReactPromise(BLOCKED, null, null);\n+  (metaData: any).$$promise = blockedPromise;\n+\n   const serverReference: ServerReference<T> =\n     resolveServerReference<$FlowFixMe>(response._bundlerConfig, id);\n   // We expect most servers to not really need this because you'd just have all\n   // the relevant modules already loaded but it allows for lazy loading of code\n   // if needed.\n   const bound = metaData.bound;\n-  let promise: null | Thenable<any> = preloadModule(serverReference);\n-  if (!promise) {\n+  let serverReferencePromise: null | Thenable<any> =\n+    preloadModule(serverReference);\n+  if (!serverReferencePromise) {\n     if (bound instanceof ReactPromise) {\n-      promise = Promise.resolve(bound);\n+      serverReferencePromise = Promise.resolve(bound);\n     } else {\n       const resolvedValue = (requireModule(serverReference): any);\n+      // Resolve the cached promise synchronously.\n+      const initializedPromise: InitializedChunk<T> = (blockedPromise: any);\n+      initializedPromise.status = INITIALIZED;\n+      initializedPromise.value = resolvedValue;\n       return resolvedValue;\n     }\n   } else if (bound instanceof ReactPromise) {\n-    promise = Promise.all([promise, bound]);\n+    serverReferencePromise = Promise.all([serverReferencePromise, bound]);\n   }\n \n   let handler: InitializationHandler;\n@@ -508,59 +502,59 @@ function loadServerReference<A: Iterable<any>, T>(\n     let resolvedValue = (requireModule(serverReference): any);\n \n     if (metaData.bound) {\n-      // This promise is coming from us and should have initilialized by now.\n+      // This promise is coming from us and should have initialized by now.\n       const promiseValue = (metaData.bound: any).value;\n-      const boundArgs: Array<any> = Array.isArray(promiseValue)\n+      const boundArgs: Array<any> = isArray(promiseValue)\n         ? promiseValue.slice(0)\n         : [];\n+      if (boundArgs.length > MAX_BOUND_ARGS) {\n+        reject(\n+          new Error(\n+            'Server Function has too many bound arguments. Received ' +\n+              boundArgs.length +\n+              ' but the limit is ' +\n+              MAX_BOUND_ARGS +\n+              '.',\n+          ),\n+        );\n+        return;\n+      }\n       boundArgs.unshift(null); // this\n       resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);\n     }\n \n-    parentObject[key] = resolvedValue;\n-\n-    // If this is the root object for a model reference, where `handler.value`\n-    // is a stale `null`, the resolved value can be used directly.\n-    if (key === '' && handler.value === null) {\n-      handler.value = resolvedValue;\n+    // Resolve the cached promise so subsequent references can use the value.\n+    const resolveListeners = blockedPromise.value;\n+    const initializedPromise: InitializedChunk<T> = (blockedPromise: any);\n+    initializedPromise.status = INITIALIZED;\n+    initializedPromise.value = resolvedValue;\n+    initializedPromise.reason = null;\n+    if (resolveListeners !== null) {\n+      // Notify any resolve listeners that were added via .then() from\n+      // subsequent loadServerReference calls for the same reference.\n+      wakeChunk(response, resolveListeners, resolvedValue, initializedPromise);\n     }\n \n-    handler.deps--;\n-\n-    if (handler.deps === 0) {\n-      const chunk = handler.chunk;\n-      if (chunk === null || chunk.status !== BLOCKED) {\n-        return;\n-      }\n-      const resolveListeners = chunk.value;\n-      const initializedChunk: InitializedChunk<T> = (chunk: any);\n-      initializedChunk.status = INITIALIZED;\n-      initializedChunk.value = handler.value;\n-      initializedChunk.reason = null;\n-      if (resolveListeners !== null) {\n-        wakeChunk(response, resolveListeners, handler.value);\n-      }\n-    }\n+    resolveReference(response, handler, parentObject, key, resolvedValue);\n   }\n \n   function reject(error: mixed): void {\n-    if (handler.errored) {\n-      // We've already errored. We could instead build up an AggregateError\n-      // but if there are multiple errors we just take the first one like\n-      // Promise.all.\n-      return;\n-    }\n-    handler.errored = true;\n-    handler.value = null;\n-    handler.reason = error;\n-    const chunk = handler.chunk;\n-    if (chunk === null || chunk.status !== BLOCKED) {\n-      return;\n+    // Mark the cached promise as errored so subsequent references fail too.\n+    const rejectListeners = blockedPromise.reason;\n+    const erroredPromise: ErroredChunk<T> = (blockedPromise: any);\n+    erroredPromise.status = ERRORED;\n+    erroredPromise.value = null;\n+    erroredPromise.reason = error;\n+    if (rejectListeners !== null) {\n+      // Notify any reject listeners that were added via .then() from subsequent\n+      // loadServerReference calls for the same reference.\n+      rejectChunk(response, rejectListeners, error);\n     }\n-    triggerErrorOnChunk(response, chunk, error);\n+\n+    rejectReference(response, handler, error);\n   }\n \n-  promise.then(fulfill, reject);\n+  serverReferencePromise.then(fulfill, reject);\n \n   // Return a place holder value for now.\n   return (null: any);\n@@ -572,10 +566,18 @@ function reviveModel(\n   parentKey: string,\n   value: JSONValue,\n   reference: void | string,\n+  arrayRoot: null | NestedArrayContext,\n ): any {\n   if (typeof value === 'string') {\n     // We can't use .bind here because we need the \"this\" value.\n-    return parseModelString(response, parentObj, parentKey, value, reference);\n+    return parseModelString(\n+      response,\n+      parentObj,\n+      parentKey,\n+      value,\n+      reference,\n+      arrayRoot,\n+    );\n   }\n   if (typeof value === 'object' && value !== null) {\n     if (\n@@ -589,16 +591,42 @@ function reviveModel(\n         reference,\n       );\n     }\n-    if (Array.isArray(value)) {\n+    if (isArray(value)) {\n+      let childContext: NestedArrayContext;\n+      if (arrayRoot === null) {\n+        childContext = ({\n+          count: 0,\n+          fork: false,\n+        }: NestedArrayContext);\n+        response._rootArrayContexts.set(value, childContext);\n+      } else {\n+        childContext = arrayRoot;\n+      }\n+      if (value.length > 1) {\n+        childContext.fork = true;\n+      }\n+      bumpArrayCount(childContext, value.length + 1, response);\n       for (let i = 0; i < value.length; i++) {\n         const childRef =\n           reference !== undefined ? reference + ':' + i : undefined;\n         // $FlowFixMe[cannot-write]\n-        value[i] = reviveModel(response, value, '' + i, value[i], childRef);\n+        value[i] = reviveModel(\n+          response,\n+          value,\n+          '' + i,\n+          value[i],\n+          childRef,\n+          childContext,\n+        );\n       }\n     } else {\n       for (const key in value) {\n         if (hasOwnProperty.call(value, key)) {\n+          if (key === __PROTO__) {\n+            // $FlowFixMe[cannot-write]\n+            delete value[key];\n+            continue;\n+          }\n           const childRef =\n             reference !== undefined && key.indexOf(':') === -1\n               ? reference + ':' + key\n@@ -609,8 +637,9 @@ function reviveModel(\n             key,\n             value[key],\n             childRef,\n+            null, // The array context resets when we're entering a non-array\n           );\n-          if (newValue !== undefined || key === '__proto__') {\n+          if (newValue !== undefined) {\n             // $FlowFixMe[cannot-write]\n             value[key] = newValue;\n           } else {\n@@ -624,6 +653,27 @@ function reviveModel(\n   return value;\n }\n \n+type NestedArrayContext = {\n+  // Keeps track of how many slots, bytes or characters are in nested arrays/strings/typed arrays.\n+  count: number,\n+  // A single child is itself not harmful. There needs to be at least one parent array with more\n+  // than one child.\n+  fork: boolean,\n+};\n+\n+function bumpArrayCount(\n+  arrayContext: NestedArrayContext,\n+  slots: number,\n+  response: Response,\n+): void {\n+  const newCount = (arrayContext.count += slots);\n+  if (newCount > response._arraySizeLimit && arrayContext.fork) {\n+    throw new Error(\n+      'Maximum array nesting exceeded. Large nested arrays can be dangerous. Try adding intermediate objects.',\n+    );\n+  }\n+}\n+\n type InitializationReference = {\n   handler: InitializationHandler,\n   parentObject: Object,\n@@ -635,6 +685,7 @@ type InitializationReference = {\n     key: string,\n   ) => any,\n   path: Array<string>,\n+  arrayRoot: null | NestedArrayContext,\n };\n type InitializationHandler = {\n   chunk: null | BlockedChunk<any>,\n@@ -666,12 +717,19 @@ function initializeModelChunk<T>(chunk: ResolvedModelChunk<T>): void {\n   try {\n     const rawModel = JSON.parse(resolvedModel);\n \n+    // The root might not be an array but if it is we want to track the count of entries.\n+    const arrayRoot: NestedArrayContext = {\n+      count: 0,\n+      fork: false,\n+    };\n+\n     const value: T = reviveModel(\n       response,\n       {'': rawModel},\n       '',\n       rawModel,\n       rootReference,\n+      arrayRoot,\n     );\n \n     // Invoke any listeners added while resolving this model. I.e. cyclic\n@@ -686,7 +744,7 @@ function initializeModelChunk<T>(chunk: ResolvedModelChunk<T>): void {\n         if (typeof listener === 'function') {\n           listener(value);\n         } else {\n-          fulfillReference(response, listener, value);\n+          fulfillReference(response, listener, value, arrayRoot);\n         }\n       }\n     }\n@@ -698,14 +756,15 @@ function initializeModelChunk<T>(chunk: ResolvedModelChunk<T>): void {\n         // We discovered new dependencies on modules that are not yet resolved.\n         // We have to keep the BLOCKED state until they're resolved.\n         initializingHandler.value = value;\n+        initializingHandler.reason = arrayRoot;\n         initializingHandler.chunk = cyclicChunk;\n         return;\n       }\n     }\n     const initializedChunk: InitializedChunk<T> = (chunk: any);\n     initializedChunk.status = INITIALIZED;\n     initializedChunk.value = value;\n-    initializedChunk.reason = null;\n+    initializedChunk.reason = arrayRoot;\n   } catch (error) {\n     const erroredChunk: ErroredChunk<T> = (chunk: any);\n     erroredChunk.status = ERRORED;\n@@ -727,7 +786,11 @@ export function reportGlobalError(response: Response, error: Error): void {\n     if (chunk.status === PENDING) {\n       triggerErrorOnChunk(response, chunk, error);\n     } else if (chunk.status === INITIALIZED && chunk.reason !== null) {\n-      chunk.reason.error(error);\n+      const maybeController = chunk.reason;\n+      // $FlowFixMe\n+      if (typeof maybeController.error === 'function') {\n+        maybeController.error(error);\n+      }\n     }\n   });\n }\n@@ -759,10 +822,14 @@ function fulfillReference(\n   response: Response,\n   reference: InitializationReference,\n   value: any,\n+  arrayRoot: null | NestedArrayContext,\n ): void {\n   const {handler, parentObject, key, map, path} = reference;\n \n+  let resolvedValue;\n   try {\n+    let localLength: number = 0;\n+    const rootArrayContexts = response._rootArrayContexts;\n     for (let i = 1; i < path.length; i++) {\n       // The server doesn't have any lazy references so we don't expect to go through a Promise.\n       const name = path[i];\n@@ -774,26 +841,77 @@ function fulfillReference(\n         hasOwnProperty.call(value, name)\n       ) {\n         value = value[name];\n+        if (isArray(value)) {\n+          localLength = 0;\n+          arrayRoot = rootArrayContexts.get(value) || arrayRoot;\n+        } else {\n+          arrayRoot = null;\n+          if (typeof value === 'string') {\n+            localLength = value.length;\n+          } else if (typeof value === 'bigint') {\n+            // Estimate the length to avoid expensive toString() calls on large\n+            // BigInt values. If the value is too large, we get Infinity, which\n+            // will trigger the array size limit error.\n+            // eslint-disable-next-line react-internal/no-primitive-constructors\n+            const n = Math.abs(Number(value));\n+            if (n === 0) {\n+              localLength = 1;\n+            } else {\n+              localLength = Math.floor(Math.log10(n)) + 1;\n+            }\n+          } else if (ArrayBuffer.isView(value)) {\n+            localLength = value.byteLength;\n+          } else {\n+            localLength = 0;\n+          }\n+        }\n       } else {\n         throw new Error('Invalid reference.');\n       }\n     }\n \n-    const mappedValue = map(response, value, parentObject, key);\n-    parentObject[key] = mappedValue;\n+    resolvedValue = map(response, value, parentObject, key);\n \n-    // If this is the root object for a model reference, where `handler.value`\n-    // is a stale `null`, the resolved value can be used directly.\n-    if (key === '' && handler.value === null) {\n-      handler.value = mappedValue;\n+    // Add any array counts to the reference's array root. The value that we're\n+    // resolving might have deep nesting that we need to resolve.\n+    const referenceArrayRoot = reference.arrayRoot;\n+    if (referenceArrayRoot !== null) {\n+      if (arrayRoot !== null) {\n+        if (arrayRoot.fork) {\n+          referenceArrayRoot.fork = true;\n+        }\n+        bumpArrayCount(referenceArrayRoot, arrayRoot.count, response);\n+      } else if (localLength > 0) {\n+        bumpArrayCount(referenceArrayRoot, localLength, response);\n+      }\n     }\n   } catch (error) {\n-    rejectReference(response, reference.handler, error);\n+    rejectReference(response, handler, error);\n     return;\n   }\n \n   // There are no Elements or Debug Info to transfer here.\n \n+  resolveReference(response, handler, parentObject, key, resolvedValue);\n+}\n+\n+function resolveReference(\n+  response: Response,\n+  handler: InitializationHandler,\n+  parentObject: Object,\n+  key: string,\n+  resolvedValue: mixed,\n+): void {\n+  if (key !== __PROTO__) {\n+    parentObject[key] = resolvedValue;\n+  }\n+\n+  // If this is the root object for a model reference, where `handler.value`\n+  // is a stale `null`, the resolved value can be used directly.\n+  if (key === '' && handler.value === null) {\n+    handler.value = resolvedValue;\n+  }\n+\n   handler.deps--;\n \n   if (handler.deps === 0) {\n@@ -807,7 +925,7 @@ function fulfillReference(\n     initializedChunk.value = handler.value;\n     initializedChunk.reason = handler.reason; // Used by streaming chunks\n     if (resolveListeners !== null) {\n-      wakeChunk(response, resolveListeners, handler.value);\n+      wakeChunk(response, resolveListeners, handler.value, initializedChunk);\n     }\n   }\n }\n@@ -835,10 +953,11 @@ function rejectReference(\n }\n \n function waitForReference<T>(\n-  referencedChunk: PendingChunk<T> | BlockedChunk<T>,\n+  response: Response,\n+  referencedChunk: BlockedChunk<T>,\n   parentObject: Object,\n   key: string,\n-  response: Response,\n+  arrayRoot: null | NestedArrayContext,\n   map: (response: Response, model: any, parentObject: Object, key: string) => T,\n   path: Array<string>,\n ): T {\n@@ -862,6 +981,7 @@ function waitForReference<T>(\n     key,\n     map,\n     path,\n+    arrayRoot,\n   };\n \n   // Add \"listener\".\n@@ -885,6 +1005,7 @@ function getOutlinedModel<T>(\n   reference: string,\n   parentObject: Object,\n   key: string,\n+  referenceArrayRoot: null | NestedArrayContext,\n   map: (response: Response, model: any, parentObject: Object, key: string) => T,\n ): T {\n   const path = reference.split(':');\n@@ -899,6 +1020,9 @@ function getOutlinedModel<T>(\n   switch (chunk.status) {\n     case INITIALIZED:\n       let value = chunk.value;\n+      let arrayRoot: null | NestedArrayContext = chunk.reason;\n+      let localLength: number = 0;\n+      const rootArrayContexts = response._rootArrayContexts;\n       for (let i = 1; i < path.length; i++) {\n         const name = path[i];\n         if (\n@@ -909,16 +1033,64 @@ function getOutlinedModel<T>(\n           hasOwnProperty.call(value, name)\n         ) {\n           value = value[name];\n+          if (isArray(value)) {\n+            localLength = 0;\n+            arrayRoot = rootArrayContexts.get(value) || arrayRoot;\n+          } else {\n+            arrayRoot = null;\n+            if (typeof value === 'string') {\n+              localLength = value.length;\n+            } else if (typeof value === 'bigint') {\n+              // Estimate the length to avoid expensive toString() calls on large\n+              // BigInt values. If the value is too large, we get Infinity, which\n+              // will trigger the array size limit error.\n+              // eslint-disable-next-line react-internal/no-primitive-constructors\n+              const n = Math.abs(Number(value));\n+              if (n === 0) {\n+                localLength = 1;\n+              } else {\n+                localLength = Math.floor(Math.log10(n)) + 1;\n+              }\n+            } else if (ArrayBuffer.isView(value)) {\n+              localLength = value.byteLength;\n+            } else {\n+              localLength = 0;\n+            }\n+          }\n         } else {\n           throw new Error('Invalid reference.');\n         }\n       }\n       const chunkValue = map(response, value, parentObject, key);\n+\n+      // Add any array counts to the reference's array root. The value that we're\n+      // resolving might have deep nesting that we need to resolve.\n+      if (referenceArrayRoot !== null) {\n+        if (arrayRoot !== null) {\n+          if (arrayRoot.fork) {\n+            referenceArrayRoot.fork = true;\n+          }\n+          bumpArrayCount(referenceArrayRoot, arrayRoot.count, response);\n+        } else if (localLength > 0) {\n+          bumpArrayCount(referenceArrayRoot, localLength, response);\n+        }\n+      }\n       // There's no Element nor Debug Info in the ReplyServer so we don't have to check those here.\n       return chunkValue;\n-    case PENDING:\n     case BLOCKED:\n-      return waitForReference(chunk, parentObject, key, response, map, path);\n+      return waitForReference(\n+        response,\n+        chunk,\n+        parentObject,\n+        key,\n+        referenceArrayRoot,\n+        map,\n+        path,\n+      );\n+    case PENDING:\n+      // If we don't have the referenced chunk yet, then this must be a forward reference,\n+      // which is not allowed.\n+      throw new Error('Invalid forward reference.');\n     default:\n       // This is an error. Instead of erroring directly, we're going to encode this on\n       // an initialization handler.\n@@ -944,16 +1116,40 @@ function createMap(\n   response: Response,\n   model: Array<[any, any]>,\n ): Map<any, any> {\n-  return new Map(model);\n+  if (!isArray(model)) {\n+    throw new Error('Invalid Map initializer.');\n+  }\n+  if ((model as any).$$consumed === true) {\n+    throw new Error('Already initialized Map.');\n+  }\n+  const map = new Map(model);\n+  (model as any).$$consumed = true;\n+  return map;\n }\n \n function createSet(response: Response, model: Array<any>): Set<any> {\n-  return new Set(model);\n+  if (!isArray(model)) {\n+    throw new Error('Invalid Set initializer.');\n+  }\n+  if ((model as any).$$consumed === true) {\n+    throw new Error('Already initialized Set.');\n+  }\n+  const set = new Set(model);\n+  (model as any).$$consumed = true;\n+  return set;\n }\n \n function extractIterator(response: Response, model: Array<any>): Iterator<any> {\n+  if (!isArray(model)) {\n+    throw new Error('Invalid Iterator initializer.');\n+  }\n+  if ((model as any).$$consumed === true) {\n+    throw new Error('Already initialized Iterator.');\n+  }\n   // $FlowFixMe[incompatible-use]: This uses raw Symbols because we're extracting from a native array.\n-  return model[Symbol.iterator]();\n+  const iterator = model[Symbol.iterator]();\n+  (model as any).$$consumed = true;\n+  return iterator;\n }\n \n function createModel(\n@@ -977,6 +1173,7 @@ function parseTypedArray<T: $ArrayBufferView | ArrayBuffer>(\n   bytesPerElement: number,\n   parentObject: Object,\n   parentKey: string,\n+  referenceArrayRoot: null | NestedArrayContext,\n ): null {\n   const id = parseInt(reference.slice(2), 16);\n   const prefix = response._prefix;\n@@ -985,10 +1182,15 @@ function parseTypedArray<T: $ArrayBufferView | ArrayBuffer>(\n   if (chunks.has(id)) {\n     throw new Error('Already initialized typed array.');\n   }\n+  chunks.set(\n+    id,\n+    // We don't need to put the actual Blob in the chunk,\n+    // because it shouldn't be accessed by anything else.\n+    createErroredChunk(response, new Error('Already initialized typed array.')),\n+  );\n \n   // We should have this backingEntry in the store already because we emitted\n   // it before referencing it. It should be a Blob.\n-  // TODO: Use getOutlinedModel to allow us to emit the Blob later. We should be able to do that now.\n   const backingEntry: Blob = (response._formData.get(key): any);\n \n   const promise: Promise<ArrayBuffer> = backingEntry.arrayBuffer();\n@@ -1011,17 +1213,28 @@ function parseTypedArray<T: $ArrayBufferView | ArrayBuffer>(\n   }\n \n   function fulfill(buffer: ArrayBuffer): void {\n-    const resolvedValue: T =\n-      constructor === ArrayBuffer\n-        ? (buffer: any)\n-        : (new constructor(buffer): any);\n+    try {\n+      if (referenceArrayRoot !== null) {\n+        bumpArrayCount(referenceArrayRoot, buffer.byteLength, response);\n+      }\n \n-    parentObject[parentKey] = resolvedValue;\n+      const resolvedValue: T =\n+        constructor === ArrayBuffer\n+          ? (buffer: any)\n+          : (new constructor(buffer): any);\n \n-    // If this is the root object for a model reference, where `handler.value`\n-    // is a stale `null`, the resolved value can be used directly.\n-    if (parentKey === '' && handler.value === null) {\n-      handler.value = resolvedValue;\n+      if (key !== __PROTO__) {\n+        parentObject[parentKey] = resolvedValue;\n+      }\n+\n+      // If this is the root object for a model reference, where `handler.value`\n+      // is a stale `null`, the resolved value can be used directly.\n+      if (parentKey === '' && handler.value === null) {\n+        handler.value = resolvedValue;\n+      }\n+    } catch (x) {\n+      reject(x);\n+      return;\n     }\n \n     handler.deps--;\n@@ -1035,9 +1248,11 @@ function parseTypedArray<T: $ArrayBufferView | ArrayBuffer>(\n       const initializedChunk: InitializedChunk<T> = (chunk: any);\n       initializedChunk.status = INITIALIZED;\n       initializedChunk.value = handler.value;\n+      // We don't keep an array count for this since it won't be referenced again.\n+      // In fact, we don't really need to store this chunk at all.\n       initializedChunk.reason = null;\n       if (resolveListeners !== null) {\n-        wakeChunk(response, resolveListeners, handler.value);\n+        wakeChunk(response, resolveListeners, handler.value, initializedChunk);\n       }\n     }\n   }\n@@ -1111,6 +1326,13 @@ function parseReadableStream<T>(\n     },\n   });\n   let previousBlockedChunk: SomeChunk<T> | null = null;\n+  function enqueue(value: T): void {\n+    if (type === 'bytes' && !ArrayBuffer.isView(value)) {\n+      flightController.error(new Error('Invalid data for bytes stream.'));\n+      return;\n+    }\n+    controller.enqueue(value);\n+  }\n   const flightController = {\n     enqueueModel(json: string): void {\n       if (previousBlockedChunk === null) {\n@@ -1124,22 +1346,16 @@ function parseReadableStream<T>(\n         initializeModelChunk(chunk);\n         const initializedChunk: SomeChunk<T> = chunk;\n         if (initializedChunk.status === INITIALIZED) {\n-          controller.enqueue(initializedChunk.value);\n+          enqueue(initializedChunk.value);\n         } else {\n-          chunk.then(\n-            v => controller.enqueue(v),\n-            e => controller.error((e: any)),\n-          );\n+          chunk.then(enqueue, flightController.error);\n           previousBlockedChunk = chunk;\n         }\n       } else {\n         // We're still waiting on a previous chunk so we can't enqueue quite yet.\n         const blockedChunk = previousBlockedChunk;\n         const chunk: SomeChunk<T> = createPendingChunk(response);\n-        chunk.then(\n-          v => controller.enqueue(v),\n-          e => controller.error((e: any)),\n-        );\n+        chunk.then(enqueue, flightController.error);\n         previousBlockedChunk = chunk;\n         blockedChunk.then(function () {\n           if (previousBlockedChunk === chunk) {\n@@ -1185,24 +1401,23 @@ function parseReadableStream<T>(\n   return stream;\n }\n \n-function asyncIterator(this: $AsyncIterator<any, any, void>) {\n+function FlightIterator(\n+  this: {next: (arg: void) => SomeChunk<IteratorResult<any, any>>, ...},\n+  next: (arg: void) => SomeChunk<IteratorResult<any, any>>,\n+) {\n+  this.next = next;\n+  // TODO: Add return/throw as options for aborting.\n+}\n+// TODO: The iterator could inherit the AsyncIterator prototype which is not exposed as\n+// a global but exists as a prototype of an AsyncGenerator. However, it's not needed\n+// to satisfy the iterable protocol.\n+FlightIterator.prototype = ({}: any);\n+FlightIterator.prototype[ASYNC_ITERATOR] = function asyncIterator(\n+  this: $AsyncIterator<any, any, void>,\n+) {\n   // Self referencing iterator.\n   return this;\n-}\n-\n-function createIterator<T>(\n-  next: (arg: void) => SomeChunk<IteratorResult<T, T>>,\n-): $AsyncIterator<T, T, void> {\n-  const iterator: any = {\n-    next: next,\n-    // TODO: Add return/throw as options for aborting.\n-  };\n-  // TODO: The iterator could inherit the AsyncIterator prototype which is not exposed as\n-  // a global but exists as a prototype of an AsyncGenerator. However, it's not needed\n-  // to satisfy the iterable protocol.\n-  (iterator: any)[ASYNC_ITERATOR] = asyncIterator;\n-  return iterator;\n-}\n+};\n \n function parseAsyncIterable<T>(\n   response: Response,\n@@ -1285,7 +1500,8 @@ function parseAsyncIterable<T>(\n   const iterable: $AsyncIterable<T, T, void> = {\n     [ASYNC_ITERATOR](): $AsyncIterator<T, T, void> {\n       let nextReadIndex = 0;\n-      return createIterator(arg => {\n+      // $FlowFixMe[invalid-constructor] Flow doesn't support functions as constructors\n+      return new FlightIterator((arg: void) => {\n         if (arg !== undefined) {\n           throw new Error(\n             'Values cannot be passed to next() of AsyncIterables passed to Client Components.',\n@@ -1320,11 +1536,15 @@ function parseModelString(\n   key: string,\n   value: string,\n   reference: void | string,\n+  arrayRoot: null | NestedArrayContext,\n ): any {\n   if (value[0] === '$') {\n     switch (value[1]) {\n       case '$': {\n         // This was an escaped string value.\n+        if (arrayRoot !== null) {\n+          bumpArrayCount(arrayRoot, value.length - 1, response);\n+        }\n         return value.slice(1);\n       }\n       case '@': {\n@@ -1336,7 +1556,14 @@ function parseModelString(\n       case 'h': {\n         // Server Reference\n         const ref = value.slice(2);\n-        return getOutlinedModel(response, ref, obj, key, loadServerReference);\n+        return getOutlinedModel(\n+          response,\n+          ref,\n+          obj,\n+          key,\n+          null,\n+          loadServerReference,\n+        );\n       }\n       case 'T': {\n         // Temporary Reference\n@@ -1358,12 +1585,12 @@ function parseModelString(\n       case 'Q': {\n         // Map\n         const ref = value.slice(2);\n-        return getOutlinedModel(response, ref, obj, key, createMap);\n+        return getOutlinedModel(response, ref, obj, key, null, createMap);\n       }\n       case 'W': {\n         // Set\n         const ref = value.slice(2);\n-        return getOutlinedModel(response, ref, obj, key, createSet);\n+        return getOutlinedModel(response, ref, obj, key, null, createSet);\n       }\n       case 'K': {\n         // FormData\n@@ -1374,19 +1601,30 @@ function parseModelString(\n         // We assume that the reference to FormData always comes after each\n         // entry that it references so we can assume they all exist in the\n         // backing store already.\n-        // $FlowFixMe[prop-missing] FormData has forEach on it.\n-        backingFormData.forEach((entry: File | string, entryKey: string) => {\n+        // Clone the keys to workaround bugs in the delete-while-iterating\n+        // algorithm of FormData.\n+        const keys = Array.from(backingFormData.keys());\n+        for (let i = 0; i < keys.length; i++) {\n+          const entryKey = keys[i];\n           if (entryKey.startsWith(formPrefix)) {\n-            // $FlowFixMe[incompatible-call]\n-            data.append(entryKey.slice(formPrefix.length), entry);\n+            const entries = backingFormData.getAll(entryKey);\n+            const newKey = entryKey.slice(formPrefix.length);\n+            for (let j = 0; j < entries.length; j++) {\n+              // $FlowFixMe[incompatible-call]\n+              data.append(newKey, entries[j]);\n+            }\n+            // These entries have now all been consumed. Let's free it.\n+            // This also ensures that we don't have any entries left if we\n+            // see the same key twice.\n+            backingFormData.delete(entryKey);\n           }\n-        });\n+        }\n         return data;\n       }\n       case 'i': {\n         // Iterator\n         const ref = value.slice(2);\n-        return getOutlinedModel(response, ref, obj, key, extractIterator);\n+        return getOutlinedModel(response, ref, obj, key, null, extractIterator);\n       }\n       case 'I': {\n         // $Infinity\n@@ -1415,36 +1653,151 @@ function parseModelString(\n       }\n       case 'n': {\n         // BigInt\n-        return BigInt(value.slice(2));\n+        const bigIntStr = value.slice(2);\n+        if (bigIntStr.length > MAX_BIGINT_DIGITS) {\n+          throw new Error(\n+            'BigInt is too large. Received ' +\n+              bigIntStr.length +\n+              ' digits but the limit is ' +\n+              MAX_BIGINT_DIGITS +\n+              '.',\n+          );\n+        }\n+        if (arrayRoot !== null) {\n+          bumpArrayCount(arrayRoot, bigIntStr.length, response);\n+        }\n+        return BigInt(bigIntStr);\n       }\n-    }\n-    switch (value[1]) {\n       case 'A':\n-        return parseTypedArray(response, value, ArrayBuffer, 1, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          ArrayBuffer,\n+          1,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'O':\n-        return parseTypedArray(response, value, Int8Array, 1, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          Int8Array,\n+          1,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'o':\n-        return parseTypedArray(response, value, Uint8Array, 1, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          Uint8Array,\n+          1,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'U':\n-        return parseTypedArray(response, value, Uint8ClampedArray, 1, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          Uint8ClampedArray,\n+          1,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'S':\n-        return parseTypedArray(response, value, Int16Array, 2, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          Int16Array,\n+          2,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 's':\n-        return parseTypedArray(response, value, Uint16Array, 2, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          Uint16Array,\n+          2,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'L':\n-        return parseTypedArray(response, value, Int32Array, 4, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          Int32Array,\n+          4,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'l':\n-        return parseTypedArray(response, value, Uint32Array, 4, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          Uint32Array,\n+          4,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'G':\n-        return parseTypedArray(response, value, Float32Array, 4, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          Float32Array,\n+          4,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'g':\n-        return parseTypedArray(response, value, Float64Array, 8, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          Float64Array,\n+          8,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'M':\n-        return parseTypedArray(response, value, BigInt64Array, 8, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          BigInt64Array,\n+          8,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'm':\n-        return parseTypedArray(response, value, BigUint64Array, 8, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          BigUint64Array,\n+          8,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'V':\n-        return parseTypedArray(response, value, DataView, 1, obj, key);\n+        return parseTypedArray(\n+          response,\n+          value,\n+          DataView,\n+          1,\n+          obj,\n+          key,\n+          arrayRoot,\n+        );\n       case 'B': {\n         // Blob\n         const id = parseInt(value.slice(2), 16);\n@@ -1455,8 +1808,6 @@ function parseModelString(\n         const backingEntry: Blob = (response._formData.get(blobKey): any);\n         return backingEntry;\n       }\n-    }\n-    switch (value[1]) {\n       case 'R': {\n         return parseReadableStream(response, value, undefined, obj, key);\n       }\n@@ -1472,16 +1823,30 @@ function parseModelString(\n     }\n     // We assume that anything else is a reference ID.\n     const ref = value.slice(1);\n-    return getOutlinedModel(response, ref, obj, key, createModel);\n+    return getOutlinedModel(response, ref, obj, key, arrayRoot, createModel);\n+  }\n+  if (arrayRoot !== null) {\n+    bumpArrayCount(arrayRoot, value.length, response);\n   }\n   return value;\n }\n \n+const DEFAULT_MAX_ARRAY_NESTING = 1000000;\n+\n+// Limit BigInt size to prevent CPU exhaustion from parsing very large values.\n+// 300 digits covers most practical use cases (even 512-bit integers need only\n+// ~154 digits) and aligns with the implicit limit from the Number approximation\n+// checks in fulfillReference and getOutlinedModel.\n+const MAX_BIGINT_DIGITS = 300;\n+\n+export const MAX_BOUND_ARGS = 1000;\n+\n export function createResponse(\n   bundlerConfig: ServerManifest,\n   formFieldPrefix: string,\n   temporaryReferences: void | TemporaryReferenceSet,\n   backingFormData?: FormData = new FormData(),\n+  arraySizeLimit?: number = DEFAULT_MAX_ARRAY_NESTING,\n ): Response {\n   const chunks: Map<number, SomeChunk<any>> = new Map();\n   const response: Response = {\n@@ -1492,6 +1857,8 @@ export function createResponse(\n     _closed: false,\n     _closedReason: null,\n     _temporaryReferences: temporaryReferences,\n+    _rootArrayContexts: new WeakMap(),\n+    _arraySizeLimit: arraySizeLimit,\n   };\n   return response;\n }"
		},
		{
			"filename": "packages/react-server/src/ReactFlightServer.js",
			"status": "modified",
			"additions": 13,
			"deletions": 0,
			"changes": 13,
			"patch": "@@ -557,6 +557,8 @@ type DeferredDebugStore = {\n   existing: Map<ReactClientReference | string, number>,\n };\n \n+const __PROTO__ = '__proto__';\n+\n const OPENING = 10;\n const OPEN = 11;\n const ABORTING = 12;\n@@ -3447,6 +3449,17 @@ function renderModelDestructive(\n   // Set the currently rendering model\n   task.model = value;\n \n+  if (__DEV__) {\n+    if (parentPropertyName === __PROTO__) {\n+      callWithDebugContextInDEV(request, task, () => {\n+        console.error(\n+          'Expected not to serialize an object with own property `__proto__`. When parsed this property will be omitted.%s',\n+          describeObjectForErrorMessage(parent, parentPropertyName),\n+        );\n+      });\n+    }\n+  }\n+\n   // Special Symbol, that's very common.\n   if (value === REACT_ELEMENT_TYPE) {\n     return '$';"
		},
		{
			"filename": "scripts/error-codes/codes.json",
			"status": "modified",
			"additions": 12,
			"deletions": 1,
			"changes": 13,
			"patch": "@@ -555,5 +555,16 @@\n   \"567\": \"Already initialized stream.\",\n   \"568\": \"Already initialized typed array.\",\n   \"569\": \"Cannot have cyclic thenables.\",\n-  \"570\": \"Invalid reference.\"\n+  \"570\": \"Invalid reference.\",\n+  \"571\": \"Maximum array nesting exceeded. Large nested arrays can be dangerous. Try adding intermediate objects.\",\n+  \"572\": \"Already initialized Map.\",\n+  \"573\": \"Already initialized Set.\",\n+  \"574\": \"Invalid forward reference.\",\n+  \"575\": \"Invalid Map initializer.\",\n+  \"576\": \"Invalid Set initializer.\",\n+  \"577\": \"Invalid Iterator initializer.\",\n+  \"578\": \"Already initialized Iterator.\",\n+  \"579\": \"Invalid data for bytes stream.\",\n+  \"580\": \"Server Function has too many bound arguments. Received %s but the limit is %s.\",\n+  \"581\": \"BigInt is too large. Received %s digits but the limit is %s.\"\n }"
		}
	],
	"fetchedAt": "2026-02-22T22:50:28.753Z"
}
